<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <script src="./waves-ui-master/waves-ui.umd.js"></script>
    <script src="./waves-audio-master/examples/assets/prism.js"></script>
    <script src="./waves-audio-master/examples/assets/waves-loaders.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="./icon.jpg">
    <title>Waveform generation page</title>
    <script src="./bootstrap/dist/js/bootstrap.min.js" ></script>
    <!-- Bootstrap core CSS -->
    <link href="bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <link href="bootstrap/docs/assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="cover.css" rel="stylesheet">
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <script src="bootstrap/docs/assets/js/ie-emulation-modes-warning.js"></script>
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
    #infotext1,
    #infobutton1 {
        float: bottom-right;
    }

    #infobutton2 {
        float: bottom-right;
    }
    #player {
        position: fixed;
        left: 0;
        bottom: 0;
    }
    #sidebar {
        background-color: DimGray ;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 240px;
    }#bottombar {
        bottom: 0;
        position: absolute;
    }#timelines {
        background-color: DimGray;
        padding-bottom: 10px;
    }#macroTrack {
        background-color: #444;
        /*opacity: 0.5*/
    }#track-1 {
        background-color: #444;
    }.item.annotated-marker.selected {
        color: PeachPuff;
    }
    </style>
</head>

<body>
    <script>
    window.jQuery || document.write('<script src="../bootstrap/docs/assets/js/vendor/jquery.min.js"><\/script>')
    </script>
    <div class="site-wrapper" id="pageAnchor">
        <div class="site-wrapper-inner">
            <div class="cover-container">
                <div class="masthead clearfix">
                    <div class="inner">
                        <h3 class="masthead-brand"></h3>
                        <nav class="fixed-header">
                            <ul class="nav masthead-nav">
                            </ul>
                        </nav>
                    </div>
                </div>
                <div class="inner cover" id="timelines">
                    <h1 class="cover-heading"></h1>
                    <br>
                    <div id="sidebar">
                        <a href="index.html">Song selection</a>
                        <div id="player"></div>
                    </div>
                    <div class="macroTrack" id="macroTrack"></div>
                    <br>
                    <div class="track" id="track-1"></div>
                    <div class="lead" id="loading"><img src="loading.gif" alt="loadingGif" height="50" width="50"></div>
                    <div class="waveform-box" id="waveform"></div>
                    <div style="text-align: center">
                        <button type="button" class="btn btn-default btn-sm" id="playButton" onclick="playOrPause()">
                          <span class="glyphicon glyphicon-play"></span> Play
                        </button>
                        <button type="button" class="btn btn-default btn-sm" id="clickToggle" onclick="toggleClick()">
                          <span class="	glyphicon glyphicon-volume-up"></span> Click ON
                        </button>
                        <button type="button" class="btn btn-default btn-sm" onclick="splitSegOnBeat()">
                          <span class="glyphicon glyphicon-scissors"></span> split on selected beat
                        </button>
                        <button type="button" class="btn btn-default btn-sm" onclick="mergeSegmentsOnBeat()">
                          <span class="	glyphicon glyphicon-erase"></span> merge left on selected beat
                        </button>
                        <button type="button" class="btn btn-default btn-sm" onclick="clearMarkers()" data-toggle="tooltip" data-placement="right" title="You can also select a single marker and press delete to remove it!">
                          <span class="glyphicon glyphicon-trash"></span> Clear all markers
                        </button>
                    </div>
                    <p class="lead">Press the 'b' key on the beat to add a beat annotation.
                        <a href="#" id="infotext1" data-toggle="tooltip" data-placement="right" title="Drag a beat marker to move it, or double click to delete it.">
                            <i class="material-icons">help_outline</i>
                        </a>
                    </p>
                    <p class="lead">
                        <a href="#" class="btn btn-lg btn-default" id="toPHP" onclick="writeToFile()">Save Annotations</a>
                        <a href="#" class="btn btn-lg btn-default" id="toPHP" onclick="autocomplete()">Autocomplete</a>
                        <a href="#" id="infotext2" data-toggle="tooltip" data-placement="right" title="Click here when you are finished annotating. Your beat annotations will be saved on the server.">
                            <i class="material-icons">help_outline</i>
                        </a>
                    </p>
                    <p id="showTimeStamps"></p>
                    <textarea rows="4" cols="50" id="markerInfo" style="color:black" hidden>nothing here</textarea>
                </div>
                <div id="bottombar">
                    <div class="inner">
                        <p>Waveform generation by <a href="http://wavesjs.github.io/">WavesJS-UI</a>, Project Members <a href="#">@rockforr</a>, <a href="#">@blane</a>, <a href="#">@nindia</a>, <a href="#">@clarayeah__</a>, <a href="#">@adrivri</a>.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script class="example" rel="track-1">

    var markerCounter = 1;
    var loader = new wavesLoaders.AudioBufferLoader();
    // var ytAudio = './wavfiles/' + getYoutubeId() + '.wav';
    var ytAudio = '../mp3files/' + getYoutubeId() + '.mp3';
    // var ytAudio = 'https://dl.dropboxusercontent.com/s/x96jtzww89u8cdf/Brains.wav'
    loader.load(ytAudio).then(function(buffer) {
        initialize(buffer);
    });

    var x = document.createElement("AUDIO");
    if (x.canPlayType("audio/mpeg")) {
        x.setAttribute("src", ytAudio);
        x.setAttribute("hidden", "hidden");
    }
    x.setAttribute("controls", "controls");
    document.body.appendChild(x);

    // variables we need to be global
    var data;
    var markerLayer;
    var beatMarkers = [];
    var segmentLayer;
    var cursorLayerMacro;
    var cursorLayer;
    var playSong;
    var timelineMacro;
    var timeline;
    var trackMacro;
    var track;
    var timeContextMacro;
    var timeContext;
    var startTime;
    var currentTime;
    var finalDur;
    var windowWidth = 20;
    var markerQueue = [];
    var layerHeight = 170; // height of waveform
    var timeAxisHeight = 23; // height of text above waveform
    var seeking = false;
    var newMousePos = null;
    var prevMousePos = null;
    var audioplayer = document.getElementsByTagName("AUDIO")[0];
    var duration;

    function initialize(buffer) {
        var $trackMacro = document.querySelector('#macroTrack');
        var $track = document.querySelector('#track-1');
        var width = $track.getBoundingClientRect().width;
        var macroTimeOverhead = 12;
        var layerHeight = 170; // height of waveform
        var macroTimelineHeight = 68; // height of zoomed out view
        duration = buffer.duration;
        if (duration > 900) {
            window.alert('Sorry, this song is too long for this application for to handle');
            window.location.assign('index.html')
        }
        var pixelsPerSecond = width / duration;

        segments = [{x: 0, width: duration, height: layerHeight, top: timeAxisHeight,
                color: 'steelblue', opacity: 0.2, text: '4/4'}, ];

        timeline = new wavesUI.core.Timeline(pixelsPerSecond, width);
        timelineMacro = new wavesUI.core.Timeline(pixelsPerSecond, width);

        track = timeline.createTrack($track, layerHeight + timeAxisHeight, 'main');
        trackMacro = timelineMacro.createTrack($trackMacro, macroTimelineHeight, 'macro');

        timeContext = new wavesUI.core.LayerTimeContext(timeline.timeContext);
        timeContextMacro = new wavesUI.core.LayerTimeContext(timelineMacro.timeContext);


        // time axis
        var timeAxis = new wavesUI.axis.AxisLayer(wavesUI.axis.timeAxisGenerator(), {
            height: timeAxisHeight
        });
        var timeAxisMacro = new wavesUI.axis.AxisLayer(wavesUI.axis.timeAxisGenerator(), {
            height: macroTimelineHeight
        });

        timeAxis.setTimeContext(timeline.timeContext);
        timeAxis.configureShape(wavesUI.shapes.Ticks, {}, {
            color: '#999'
        });
        track.add(timeAxis);

        timeAxisMacro.setTimeContext(timelineMacro.timeContext);
        timeAxisMacro.configureShape(wavesUI.shapes.Ticks,{},{
            color: '#555'
        });
        trackMacro.add(timeAxisMacro);


        // waveform layer
        var waveformLayer = new wavesUI.helpers.WaveformLayer(buffer, {
            height: layerHeight,
            top: timeAxisHeight,
            color: 'CadetBlue'
        });
        waveformLayer.setTimeContext(new wavesUI.core.LayerTimeContext(timeline.timeContext));
        track.add(waveformLayer);


        // Segment layer
        segmentLayer = new wavesUI.helpers.SegmentLayer(segments, {
            height: layerHeight,
            top: timeAxisHeight,
            displayHandlers: false,
        });
        timeline.addLayer(segmentLayer, 'main');


        // Marker layer
        markerLayer = new wavesUI.core.Layer('collection', beatMarkers, {
            height: layerHeight,
            top: timeAxisHeight
        });
        markerLayer.setTimeContext(timeContext);
        markerLayer.configureShape(wavesUI.shapes.AnnotatedMarker, {
            x: function(d, v) {
                if (v !== undefined) {
                    d.time = v;
                }
                return d.time;
            },
            color: function(d,v) {
              return dynamicColors(d);
            }
        });
        markerLayer.setBehavior(new wavesUI.behaviors.MarkerBehavior());
        track.add(markerLayer);


        // cursorLayer
        cursorLayer = new wavesUI.helpers.CursorLayer({
            height: layerHeight + timeAxisHeight,
            color: 'white'
        });
        timeline.addLayer(cursorLayer, 'main');

        cursorLayerMacro = new wavesUI.helpers.CursorLayer({
            height: layerHeight,
            color: 'white'
        });
        timelineMacro.addLayer(cursorLayerMacro, 'macro');

        timeline.state = new wavesUI.states.SelectionState(timeline);
        segmentLayer.setContextEditable(false);

        finalDur = timeline.timeContext.visibleDuration;

        timeline.timeContext.zoom = finalDur / windowWidth;

        timeline.tracks.render();
        timeline.tracks.update();
        timelineMacro.tracks.render();
        timelineMacro.tracks.update();

        document.getElementById('loading').innerHTML = '';

        // listen for time passing...
        (function loop() {
            if (playSong) {
                var d = new Date();
                currentTime = (d.getTime() / 1000) - startTime;
                updatePlugin(false);
                setTimeout(requestAnimationFrame(loop), 20);
            } else {
                refreshQueue()
                setTimeout(function() {
                    requestAnimationFrame(loop);
                    timeline.tracks.update();
                }, 200);
            }
        }());

        timeline.on('event', function(e) {
            var eventType = e.type;
            var segment = segmentLayer.getItemFromDOMElement(e.target);
            var onTimeAxis = $.inArray(timeAxis, timeline.getHitLayers(e));

            if (segment !== null && (eventType == 'mouseover' || eventType == 'mouseout')) {
                var datum = segmentLayer.getDatumFromItem(segment);
                datum.opacity = eventType == 'mouseout' ? 0.2 : 0.5;
                segmentLayer.updateShapes();
            } else if (!onTimeAxis && eventType == 'mousemove') {
                if (prevMousePos == null) {
                    prevMousePos = timeAxis.timeToPixel.invert(e.x);
                    return;
                } else {
                  newMousePos = timeAxis.timeToPixel.invert(e.x);
                  var delta = newMousePos - prevMousePos;
                  prevMousePos = newMousePos;
                  timeline.timeContext.offset = timeline.timeContext.offset + delta;
                  timeline.tracks.update();
                }
            } else if (!onTimeAxis && eventType == 'mouseup') {
                if (newMousePos == null) {
                  var newTime = timeAxis.timeToPixel.invert(e.x) - timeline.timeContext.offset;
                  player.seekTo(newTime)
                  seekTo(newTime);
                } else {
                  newMousePos = null;
                  prevMousePos = null;
                }

            }
        });

        timelineMacro.on('event', function(e) {
            var onTimeAxis = $.inArray(timeAxisMacro, timeline.getHitLayers);
            var eType = e.type;

            if (onTimeAxis && eType == 'mousemove') {
                seeking = true;
                var newTime = timeAxisMacro.timeToPixel.invert(e.x) - timelineMacro.timeContext.offset;
                cursorLayerMacro.currentPosition = newTime;
                cursorLayerMacro.update();
            } else if (onTimeAxis && eType == 'mouseup') {
                var newTime = timeAxisMacro.timeToPixel.invert(e.x) - timelineMacro.timeContext.offset;
                player.seekTo(newTime);
                seekTo(newTime);
                seeking = false;
            };
        });

    }

    // Renders all layers from the WavesJS plugin and plays a sound when
    // encountering a beat marker
    function updatePlugin(seeked) {
        if (!seeking) {
          cursorLayer.currentPosition = currentTime;
          cursorLayer.update();
          cursorLayerMacro.currentPosition = currentTime;
          cursorLayerMacro.update();
        }
        var offset = timeline.timeContext.offset;
        var cursorTooFar = currentTime+2 > (windowWidth - offset) || currentTime+2 < -offset;
        if (cursorTooFar) {
            timeline.timeContext.offset = 1.5-currentTime;
            timeline.tracks.update();
        }

        if(currentTime >= markerQueue[0] && !seeked) {
            console.log("removed beat from Queue");
            playClick();
            markerQueue.shift();
        }
    }

    function seekTo(newTime) {
        currentTime = newTime;
        var d = new Date();
        startTime = d.getTime()/1000 - currentTime;
        refreshQueue();
        audioplayer.currentTime = currentTime;
        updatePlugin(true);
    };

    function writeToPage() {
        document.getElementById('markerInfo').hidden = ""
        var objString = "[ ";
        for (i = 0; i < beatMarkers.length; i++) {
            var temp = beatMarkers[i];
            SingleObjString = "{ " + temp.time.toString() + ", " + temp.text.toString() + " },";
            objString = objString + SingleObjString;
        }
        objString = objString.replace(/,$/, "") + " ]";

        document.getElementById('markerInfo').value = objString;
    }

    function writeToFile() {
        var done = window.confirm("Are you sure you are done annotating? You cannot make any more changes after saving your annotations to the server.");
        if(!done) {
            return;
        }
        var toSend = [];
        for (i = 0; i < beatMarkers.length; i++) {
            toSend.push(beatMarkers[i].time);
        }
        console.log(toSend);
        var xhttp;
        var url = "writefile.php";
        var params = "beat=" + toSend.toString();
        var ytID = "ytID=" + getYoutubeId();
        if (window.XMLHttpRequest) {
            // code for modern browsers
            xhttp = new XMLHttpRequest();
        } else {
            // code for IE6, IE5
            xhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        xhttp.open("POST", "writefile.php", true);
        //Send the proper header information along with the request
        xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        xhttp.onreadystatechange = function() {
        if (xhttp.readyState == 4 && xhttp.status == 200) {
            document.getElementById("demo").innerHTML = xhttp.responseText;
            }
        };
        xhttp.send(params + "&" + ytID);
        window.alert("Thank you! Your beat annotations are saved to the server.");
    }


    function clearMarkers() {
        beatMarkers.length = 0;
        markerLayer.render();
        markerLayer.update();
        markerCounter = 1;
    }

    window.addEventListener("keydown", checkKeyPressed, false);
    window.addEventListener("mouseup", mouseUpOutOfBounds, false);

    function mouseUpOutOfBounds() {
        seeking = false;
        setTimeout(function(){newMousePos=null},10)
        prevMousePos = null;
    }

    var clickSound = new Audio('click.ogg');
    var clickSound2 = new Audio('click.ogg');

    var metronome = 1;

    function toggleClick() {
        if (metronome > 0) {
            metronome = 0;
            document.getElementById('clickToggle').innerHTML = '<span class="	glyphicon glyphicon-volume-off"></span> Click OFF'
        } else {
            metronome = 1;
            document.getElementById('clickToggle').innerHTML = '<span class="	glyphicon glyphicon-volume-up"></span> Click ON'
        }
    }

    function playClick() {
        if (metronome == 1) {
            clickSound.play();
            metronome = 2;
        } else if (metronome == 2) {
            clickSound2.play();
            metronome = 1;
        }
    }

    // Gets the Youtube video-ID from the URL
    function getYoutubeId() {
        var query = window.location.search.substring(1);
        var id = query.split("=");
        return id[1];
    }

    // Implementation of the Youtube API, retrieved and modified from: https://developers.google.com/youtube/iframe_api_reference
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";

    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    // This function creates an <iframe> (and YouTube player)
    // after the API code downloads.
    var player;

    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            height: '240',
            width: '240',
            videoId: getYoutubeId(),
            playerVars: {
                'controls': 0,
                'autoplay': 0,
                'fs': 0,
                'disablekb': 0
            },
            events: {
                'onStateChange': onPlayerStateChange
            }
        });
    };

    // When the yt player's state changes, synchronizes the wavesurfer player
    var done = false;

    // Pauses the YT video when it's playing and starts playback when it's paused.
    function playOrPause() {
        if (player.getPlayerState() == 1) {
            player.pauseVideo();
            document.getElementById('playButton').innerHTML = '<i class="glyphicon glyphicon-play"></i> Play'
        } else {
            refreshQueue();
            player.playVideo();
            document.getElementById('playButton').innerHTML = '<i class="glyphicon glyphicon-pause"></i> Pause';
        }
    }

    function onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PLAYING && !done) {
            player.mute();
            var d = new Date();
            startTime = d.getTime() / 1000;
            currentTime = player.getCurrentTime();
            audioplayer.play();
            audioplayer.currentTime = currentTime;
            refreshQueue();
            playSong = true;
            done = true;
        } else if (event.data != YT.PlayerState.PLAYING) {
            refreshQueue();
            audioplayer.pause();
            playSong = false;
        } else if (event.data == YT.PlayerState.PLAYING) {
            refreshQueue();
            audioplayer.play();
            seekTo(currentTime);
            playSong = true;
        }
    }

    function checkKeyPressed(e) {
        if (e.keyCode == "32") {
            e.preventDefault();
            playOrPause();
            player.seekTo(currentTime, true);
            audioplayer.currentTime = currentTime;
            return false;
        } else if (e.keyCode == "66") {
            playClick();
            recordTimeStamp(currentTime);
        } else if (e.keyCode == "46") {
            deleteMarker();
        }
    }

    function deleteMarker() {
        var selectedMarker = document.getElementsByClassName('item annotated-marker selected');
        console.log(selectedMarker[0].childNodes[2].innerHTML);
        var i;
        for (i = 0; i < beatMarkers.length; i++) {
            if (beatMarkers[i].text == selectedMarker[0].childNodes[2].innerHTML) {
                // put the element to be deleted at the end, and pop it off
                var temp = beatMarkers[i];
                beatMarkers[i] = beatMarkers[beatMarkers.length - 1];
                beatMarkers[beatMarkers.length - 1] = temp;
                beatMarkers.pop();
                break;
            }
        }
        markerLayer.render();
        markerLayer.update();
    }

    function refreshQueue() {
        markerQueue = [];
        for (var i = 0; i < beatMarkers.length; i++) {
            if(beatMarkers[i].time > currentTime){
                markerQueue.push(beatMarkers[i].time);
            }
        }
        markerQueue.sort(function(a,b) {
            return a-b;
        });
    }

    function recordTimeStamp(markerTime) {
        var newmarker = {
            time: markerTime,
            text: markerCounter.toString(),
        }
        markerCounter++;
        beatMarkers.push(newmarker);
        markerLayer.render();
        markerLayer.update();
    }


    function autocomplete() {
        begin = 0;
        end = 0;
        var selectedMarker = document.getElementsByClassName('item annotated-marker selected');
        var j;
        for (var j = 0; j < beatMarkers.length; j++) {
            if (beatMarkers[j].text == selectedMarker[0].childNodes[2].innerHTML) {
                // put the element to be deleted at the end, and pop it off
                var dataSelectedMarker = beatMarkers[j];
                begin = dataSelectedMarker.time;
                break;
            }
        }

        for (var i = 0; i < segments.length; i++) {
            if(segments[i].x <= begin && begin < (segments[i].x + segments[i].width)) {
                end = segments[i].x + segments[i].width;
                begin = segments[i].x;
                break;
            }
        }

        var markerTimes = [];
        for (i = 0; i < beatMarkers.length; i++) {
            console.log("beatmarkers[i].time ", beatMarkers[i].time);
            console.log("begin ", begin);
            console.log("end ", end);
            if(begin < beatMarkers[i].time && beatMarkers[i].time < end) {
                markerTimes.push(beatMarkers[i].time);
            }
        }
        markerTimes.sort(function(a,b) {
            return a-b;
        });

        console.log(markerTimes);
        var betweenTimes = [];
        for (var i = 1; i < markerTimes.length; i++) {
            betweenTimes.push(markerTimes[i] - markerTimes[i - 1]);
        }
        console.log(betweenTimes);

        var sum = 0;
        for(var i = 0; i < betweenTimes.length; i++) {
            sum += betweenTimes[i];
        }
        var avg = sum / betweenTimes.length;
        console.log(avg);

        console.log('markertimes ', markerTimes);
        var time = markerTimes[markerTimes.length - 1] + avg;
        console.log("time", time);
        console.log("begin", begin);
        console.log("end", end);
        while(time < end) {
            recordTimeStamp(time);
            time = time + avg;
            console.log(time, end);
        }
        console.log("beegees", beatMarkers);


        // neem de 8 timestamps uit de beatMarkers
        // bereken de gemiddelde tijd die ertussen zit
        // voeg zoveel beats toe als autocomplete (steeds gemiddeldeTijdErtussen uit elkaar)
    }

    function splitSegments(segments, splitTime) {
        var newSegment = {
            x: splitTime,
            width: splitTime,
            height: layerHeight,
            top: timeAxisHeight,
            color: 'steelblue',
            opacity: 0.2,
            text: '4/4'
        };
        for (var i = 0; i < segments.length; i++) {
            if (segments[i].x < splitTime && splitTime < (segments[i].x + segments[i].width)){
                oldWidth = segments[i].width;
                segments[i].width = splitTime - segments[i].x;
                newSegment.width = oldWidth - segments[i].width;
                segments.push(newSegment);
                break;
            }
        }
        segmentLayer.render();
        segmentLayer.update();
    }

    function splitSegOnBeat() {
        var selectedMarker = document.getElementsByClassName('item annotated-marker selected');
        var j;
        for (var j = 0; j < beatMarkers.length; j++) {
            if (beatMarkers[j].text == selectedMarker[0].childNodes[2].innerHTML) {
                // put the element to be deleted at the end, and pop it off
                var dataSelectedMarker = beatMarkers[j];
                startTime = dataSelectedMarker.time;
                break;
            }
        }
        splitSegments(segments, startTime);
    }

    // Merges segment that contains mergeTime with the previous segment
    function mergeSegmentsLeft(segments, mergeTime) {
        var selectedSegment;
        var endTimePreviousSeg;
        for (var i = 0; i < segments.length; i++) {
            if(segments[i].x <= mergeTime && mergeTime < (segments[i].width + segments[i].x)) {
                selectedSegment = i;
                endTimePreviousSeg = segments[i].x;
                break;
            }
        }
        for (var i = 0; i < segments.length; i++) {
            if(endTimePreviousSeg == (segments[i].x + segments[i].width)) {
                segments[selectedSegment].x = segments[i].x;
                segments[selectedSegment].width = segments[selectedSegment].width + segments[i].width;
                segments.splice(i,1);
                console.log("spliced stuff.");
                break;
            }
        }
        console.log("merged stuff maybe.");
    }

    function mergeSegmentsOnBeat() {
        var selectedMarker = document.getElementsByClassName('item annotated-marker selected');
        var j;
        for (var j = 0; j < beatMarkers.length; j++) {
            if (beatMarkers[j].text == selectedMarker[0].childNodes[2].innerHTML) {
                // put the element to be deleted at the end, and pop it off
                var dataSelectedMarker = beatMarkers[j];
                mergeTime = dataSelectedMarker.time;
                break;
            }
        }
        mergeSegmentsLeft(segments, mergeTime);
        segmentLayer.render();
        segmentLayer.update();
        console.log(segments);
    }

    function dynamicColors(d) {
      // // DOESNT WORK
      // var selected;
      // if ($.inArray(d, markerLayer.selectedItems)) {
      //     selected = true;
      // }
      for (var i = 0; i<segments.length; i++) {
          var diff = Math.abs(segments[i].x - d.time);
          if (diff < 0.0001 && selected) {
              return '#cccc00';
          } else if (diff < 0.0001) {
              return 'yellow';
          }
      }
      if (selected) {
          return '#cc0000'
      }
      return 'red';
    }

    // cleans the Segments array
    function cleanSegments(segments) {

    }
    </script>
</body>

</html>
