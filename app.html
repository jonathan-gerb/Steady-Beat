<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <script src="./waves-ui-master/waves-ui.umd.js"></script>
    <script src="./waves-audio-master/examples/assets/prism.js"></script>
    <script src="./waves-audio-master/examples/assets/waves-loaders.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="./icon.jpg">
    <title>BEAT app</title>
    <script src="./bootstrap/dist/js/bootstrap.min.js" ></script>
    <!-- Bootstrap core CSS -->
    <link href="bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <link href="bootstrap/docs/assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="cover.css" rel="stylesheet">
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <script src="bootstrap/docs/assets/js/ie-emulation-modes-warning.js"></script>
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
    #player {
        position: fixed;
        left: 0;
        bottom: 0;
    }
    #sidebar {
        background-color: #565656 ;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 300px;
    }#sidebarRight {
        background-color: #565656 ;
        position: absolute;
        top: 0;
        bottom: 0;
        right: 0;
        width: 240px;
    }#bottombar {
        bottom: 0;
        position: absolute;
    }#timelines {
        background-color: #505050;
        padding-bottom: 10px;
    }#macroTrack {
        background-color: #575757;
        /*opacity: 0.5*/
    }#track-1 {
        background-color: #666666;
    }#playButton {
        width: 6em;  height: 3em;
    }.btn-default {
        margin: 3px;
    }.panel-body {
        color: White;
        background-color: #333;
    }.dropdown {
        color:black;
    }
    </style>
</head>

<body>
    <script>
    window.jQuery || document.write('<script src="bootstrap/docs/assets/js/vendor/jquery.min.js"><\/script>')
    </script>
    <div class="site-wrapper" id="pageAnchor">
        <div class="site-wrapper-inner">
            <div class="cover-container">
                <div class="masthead clearfix">
                    <div class="inner">
                        <h3 class="masthead-brand"></h3>
                        <nav class="fixed-header">
                            <ul class="nav masthead-nav">
                            </ul>
                        </nav>
                    </div>
                </div>
                <div class="inner cover" id="timelines">
                    <h1 class="cover-heading"></h1>
                    <br>
                    <div id="sidebar">
                        <div style="background-color:#333;" class="panel-heading">
                            <button type="button" onclick="gotoSongSelection()" data-toggle="tooltip" data-placement="center" title="SongSelection" style="background-color:#333; border:none;">
                              <h4> Home </h4>
                            </button>
                        </div>
                        <div id="player"></div>

                        <div class="panel-group" id="accordionAbove"  >
                            <div class="panel panel-default" style="border:#333;">
                                <div class="panel-heading" style="background-color: #333;">
                                    <h4 class="panel-title">
                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordionAbove" href="#collapseAll"><h4> Help &amp Info</h4></a>
                                    </h4>
                                </div>
                                <div id="collapseAll" class="panel-collapse collapse">
                                    <div class="panel-body" >

                                        <div class="panel-group" id="accordion" style="overflow-y:auto; direction:rtl; height:40vh;">
                                            <div class="panel panel-default" style="border-color: #333;">
                                                <div class="panel-heading" style="background-color: #333;">
                                                    <h4 class="panel-title">
                                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordion" href="#collapse1"> Navigation </a>
                                                    </h4>
                                                </div>
                                                <div id="collapse1" class="panel-collapse collapse">
                                                    <div class="panel-body" >To navigate the song, you can use the upper timeline to seek over the whole song, and the lower timeline to seek with a zoomed in view. On the upper timeline: click to seek and drag the grey box to move the viewing window. Also try to drag the borders to zoom in/out!
                                                        On the lower timeline: click and drag anywhere to move the viewing window, and click the time axis to seek. </div>
                                                </div>
                                            </div>
                                            <div class="panel panel-default" style="border-color: #333;">
                                                <div class="panel-heading" style="background-color: #333;">
                                                    <h4 class="panel-title">
                                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordion" href="#collapse2"> Markers and segments </a>
                                                    </h4>
                                                </div>
                                                <div id="collapse2" class="panel-collapse collapse">
                                                    <div class="panel-body" > The red and yellow markers are beat markers, the yellow markers also mark the start of a segment. The regions that light up on mouseover are segments, use them to mark sections of time signatures, song structure, etc.
                                                        To select something, just click on it. </div>
                                                </div>
                                            </div>
                                            <div class="panel panel-default" style="border-color: #333;">
                                                <div class="panel-heading" style="background-color: #333;">
                                                    <h4 class="panel-title">
                                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordion" href="#collapse3"><span class="glyphicon glyphicon-play">    Play / Pause</span></a>
                                                    </h4>
                                                </div>
                                                <div id="collapse3" class="panel-collapse collapse">
                                                    <div class="panel-body" >Play or pause the song using the Play/Pause-button or by pressing the spacebar </div>
                                                </div>
                                            </div>
                                            <div class="panel panel-default" style="border: #333;">
                                                <div class="panel-heading" style="background-color: #333;">
                                                    <h4 class="panel-title">
                                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordion" href="#collapse4"><span class="glyphicon glyphicon-volume-up">     Click on/off</span></a>
                                                    </h4>
                                                </div>
                                                <div id="collapse4" class="panel-collapse collapse">
                                                    <div class="panel-body" >Use this button to select whether a click sound should play during playback when encountering exisiting beat markers </div>
                                                </div>
                                            </div>
                                            <div class="panel panel-default" style="border-color: #333;">
                                                <div class="panel-heading" style="background-color: #333;">
                                                    <h4 class="panel-title"
                                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordion" href="#collapse5"><span class="glyphicon glyphicon-scissors">     Split segment</span></a>
                                                    </h4>
                                                </div>
                                                <div id="collapse5" class="panel-collapse collapse">
                                                    <div class="panel-body" >Split the current segment into two segments (initially the entire song is one segment)
                                                    on the location of the selected beat. The selected beat becomes yellow to mark that it is
                                                    the boundary between two segments. Use segments to mark sections of time signatures,
                                                    song structure, etc</div>
                                                </div>
                                            </div>
                                            <div class="panel panel-default" style="border-color: #333;">
                                                <div class="panel-heading" style="background-color: #333;">
                                                    <h4 class="panel-title">
                                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordion" href="#collapse6"><span class="glyphicon glyphicon-erase">     Merge segments</span></a>
                                                    </h4>
                                                </div>
                                                <div id="collapse6" class="panel-collapse collapse">
                                                    <div class="panel-body" >Merge a segment with the segment left of it by selecting a beat in that segment and clicking the button with an eraser icon</div>
                                                </div>
                                            </div>
                                            <div class="panel panel-default" style="border-color: #333;">
                                                <div class="panel-heading" style="background-color: #333;">
                                                    <h4 class="panel-title">
                                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordion" href="#collapse7"><span class="glyphicon glyphicon-check">     Auto-complete</span></a>
                                                    </h4>
                                                </div>
                                                <div id="collapse7" class="panel-collapse collapse">
                                                    <div class="panel-body" >When you press the Auto-complete button (the button with a checkmark) the beat timings of the current segment will be estimated. This means that your beat timings will be used to fill the rest of the segment with beats</div>
                                                </div>
                                            </div>
                                            <div class="panel panel-default" style="border-color: #333;">
                                                <div class="panel-heading" style="background-color: #333;">
                                                    <h4 class="panel-title">
                                                        <a style="color: White;text-decoration:none" data-toggle="collapse" data-parent="#accordion" href="#collapse8">Credits</a>
                                                    </h4>
                                                </div>
                                                <div id="collapse8" class="panel-collapse collapse">
                                                    <div class="panel-body" ><p>Waveform generation by <a href="http://wavesjs.github.io/">WavesJS-UI</a>, Project Members <a href="https://nl.linkedin.com/in/jonathan-gerbscheid-501aa0112">Jonathan Gerbscheid</a>, <a href="https://www.linkedin.com/in/bart-laan-47364599">Bart Laan</a>, <a href="https://nl.linkedin.com/in/arianne-van-nieuwenhuijsen-aa1a9a112">Arianne van Nieuwenhuijsen</a>, <a href="https://hm.linkedin.com/in/clara-tump-4bb841b4">Clara Tump</a>, <a href="#">Adriaan de Vries</a>.</p></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                </div>
                            </div>
                        </div>
                    </div>
                    <p class="lead" id="ytTitle"></p>
                    <div class="macroTrack" id="macroTrack"></div>
                    <br>
                    <div class="track" id="track-1"></div>
                    <div class="lead" id="loading"><img src="loading.gif" alt="loadingGif" height="50" width="50"></div>
                    <div class="waveform-box" id="waveform"></div>
                    <div style="text-align: center">
                        <button type="button" class="btn btn-default btn-sm" id="playButton" title="Play/pause" onclick="playOrPause()">
                          <span class="glyphicon glyphicon-play"></span>
                        </button>
                        <br> <br>
                        <button type="button" class="btn btn-default btn-sm" id="clickToggle" title="Toggle the clicksound of existing beats" onclick="toggleClick()">
                          <span class="	glyphicon glyphicon-volume-up"></span>
                        </button>
                        <button type="button" class="btn btn-default btn-sm" title="Split a segment in two on the selected beat" onclick="splitSegOnBeat()">
                          <span class="glyphicon glyphicon-scissors"></span>
                        </button>
                        <button type="button" class="btn btn-default btn-sm" title="Merge the selected segment with the previous segment" onclick="mergeSegments()">
                          <span class="	glyphicon glyphicon-erase"></span>
                        </button>
                        <!-- <button type="button" class="btn btn-default btn-sm" onclick="autocomplete()"> -->
                        <button type="button" class="btn btn-default btn-sm" title="Auto-complete the selected segment" onclick="autocompletePHP()">
                          <span class="	glyphicon glyphicon-check"></span>
                        </button>
                        <img src="loading1.gif" id="loadingGif" alt="loadingGif" height="20" width="20" style="display: none" >
                        <button type="button" class="btn btn-default btn-sm" onclick="clearMarkers()" data-toggle="tooltip" data-placement="right" title="Remove beats in the selected segment. You can also select a marker and press delete to remove it">
                          <span class="glyphicon glyphicon-trash"></span>
                        </button>
                        <div id="timeSigSelect" style="visibility:hidden">
                            <br>
                            Time signature of selected segment:    <select class="dropdown" id="timeSel" onchange="timeSigChange()">
                                <option value="4/4">4/4</option>
                                <option value="3/4">3/4</option>
                                <option value="8/8">8/8</option>
                                <option value="6/8">6/8</option>
                                <option value="5/4">5/4</option>
                                <option value="7/8">7/8</option>
                                <option value="9/8">9/8</option>
                                <option value="10/8">10/8</option>
                                <option value="12/8">12/8</option>
                            </select>
                            <br>
                        </div>
                    </div>
                    <p class="lead">Press the 'b' key on the beat to add a beat annotation. </p>
                    <p class="lead">
                        <a href="#" class="btn btn-default" id="toPHP" onclick="writeToFile()">
                            <span class="glyphicon glyphicon-upload"></span>
                            Upload Annotations
                        </a>
                    </p>
                    <p id="showTimeStamps"></p>
                    <textarea rows="4" cols="50" id="markerInfo" style="color:black" hidden>nothing here</textarea>
                </div>
            </div>
        </div>
    </div>
    <!-- END OF HTML -->


    <script rel="track-1">

    // Gets the Youtube video-ID from the URL
    function getYoutubeId() {
        var query = window.location.search.substring(1);
        var id = query.split("=");
        return id[1];
    }

    // Implementation of the Youtube API, retrieved and modified from: https://developers.google.com/youtube/iframe_api_reference
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";

    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    // This function creates an <iframe> (and YouTube player)
    // after the API code downloads.
    var player;
    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            height: '240',
            width: '300',
            videoId: getYoutubeId(),
            playerVars: {
                'controls': 0,
                'autoplay': 0,
                'fs': 0,
                'disablekb': 0
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    };

    function onPlayerReady(event) {
        document.getElementById( "ytTitle" ).innerText = player.getVideoData().title;
    }

    // Take action when the youtube player changes state. This is used to play
    // or pause the html5 audioplayer and the visual plugin
    var done = false;
    function onPlayerStateChange(event) {

        // when the youtube player starts playing for the first time
        if (event.data == YT.PlayerState.PLAYING && !done) {
            player.mute();
            var d = new Date();
            startTime = d.getTime() / 1000;
            currentTime = player.getCurrentTime();
            audioplayer.play();
            audioplayer.currentTime = currentTime;
            refreshClickQueue();
            playSong = true;
            document.getElementById('playButton').innerHTML = '<i class="glyphicon glyphicon-pause"></i>';
            done = true;

        // when youtube player pauses
        } else if (event.data != YT.PlayerState.PLAYING) {
            refreshClickQueue();
            audioplayer.pause();
            playSong = false;

        // when youtube player starts playing again
        } else if (event.data == YT.PlayerState.PLAYING) {
            refreshClickQueue();
            audioplayer.play();
            seekTo(currentTime);
            playSong = true;
        }
    }

    // Initialize the WavesJS plugin, the main user interface
    var loader = new wavesLoaders.AudioBufferLoader();
    var ytAudio = './wavfiles/' + getYoutubeId() + '.wav';
    // var ytAudio = './mp3files/' + getYoutubeId() + '.mp3';
    loader.load(ytAudio).then(function(buffer) {
        initialize(buffer);
    });

    // the html audio player
    var x = document.createElement("AUDIO");
    if (x.canPlayType("audio/mpeg")) {
        x.setAttribute("src", ytAudio);
        x.setAttribute("hidden", "hidden");
    }
    x.setAttribute("controls", "controls");
    document.body.appendChild(x);

    // variables we need to be global
    var data;
    var markerLayer;
    var beatMarkers = [];
    var segmentLayer;
    var macroHighlight;
    var cursorLayerMacro;
    var cursorLayer;
    var playSong;
    var timelineMacro;
    var timeline;
    var trackMacro;
    var track;
    var timeContextMacro;
    var timeContext;
    var startTime;
    var currentTime = 0;
    var finalDur;
    var windowWidth = 20;
    var markerQueue = [];
    var layerHeight = 170; // height of waveform
    var timeAxisHeight = 23; // height of text above waveform
    var mouseMoving = false;
    var newMousePos = null;
    var prevMousePos = null;
    var audioplayer = document.getElementsByTagName("AUDIO")[0];
    var duration;

    // Creates all the components of the WavesJS plugin and renders them
    function initialize(buffer) {
        var $trackMacro = document.querySelector('#macroTrack');
        var $track = document.querySelector('#track-1');
        var width = $track.getBoundingClientRect().width;
        var macroTimeOverhead = 12;
        var layerHeight = 170; // height of waveform
        var macroTimelineHeight = 68; // height of zoomed out view
        duration = buffer.duration;
        if (duration > 900) {
            window.alert('Sorry, this song is too long for this application to handle');
            window.location.assign('index.html')
        }
        var pixelsPerSecond = width / duration;

        segments = [{x: 0, width: duration, height: layerHeight, top: timeAxisHeight,
                color: 'steelblue', opacity: 0, text: '4/4'}, ];

        macroHighlight = [{x: 0, width: 20, height: macroTimelineHeight, color: 'white', opacity: 0.2}, ];

        timeline = new wavesUI.core.Timeline(pixelsPerSecond, width);
        timelineMacro = new wavesUI.core.Timeline(pixelsPerSecond, width);

        track = timeline.createTrack($track, layerHeight + timeAxisHeight, 'main');
        trackMacro = timelineMacro.createTrack($trackMacro, macroTimelineHeight, 'macro');

        timeContext = new wavesUI.core.LayerTimeContext(timeline.timeContext);
        timeContextMacro = new wavesUI.core.LayerTimeContext(timelineMacro.timeContext);

        // create time axis
        var timeAxis = new wavesUI.axis.AxisLayer(wavesUI.axis.timeAxisGenerator(), { height: timeAxisHeight });
        var timeAxisMacro = new wavesUI.axis.AxisLayer(wavesUI.axis.timeAxisGenerator(), { height: macroTimelineHeight });

        timeAxis.setTimeContext(timeline.timeContext);
        timeAxis.configureShape(wavesUI.shapes.Ticks, {}, { color: '#999' });
        track.add(timeAxis);

        timeAxisMacro.setTimeContext(timelineMacro.timeContext);
        timeAxisMacro.configureShape(wavesUI.shapes.Ticks,{},{ color: '#777' });
        trackMacro.add(timeAxisMacro);

        // create waveform layer
        var waveformLayer = new wavesUI.helpers.WaveformLayer(buffer, { height: layerHeight, top: timeAxisHeight, color: '#B4C3BD' });
        waveformLayer.setTimeContext(new wavesUI.core.LayerTimeContext(timeline.timeContext));
        track.add(waveformLayer);

        // create segment layer
        segmentLayer = new wavesUI.helpers.SegmentLayer(segments, { height: layerHeight, top: timeAxisHeight, displayHandlers: false });
        segmentLayer.configureShape(wavesUI.shapes.AnnotatedSegment, {
            opacity: function(d,v) {
                return segmentOpacity(d);
            }
        })
        timeline.addLayer(segmentLayer, 'main');

        segmentLayerMacro = new wavesUI.helpers.SegmentLayer(macroHighlight, { height: macroTimelineHeight, displayHandlers: true });
        timelineMacro.addLayer(segmentLayerMacro, 'macro');

        // create marker layer
        markerLayer = new wavesUI.core.Layer('collection', beatMarkers, { height: layerHeight, top: timeAxisHeight });
        markerLayer.setTimeContext(timeContext);
        markerLayer.configureShape(wavesUI.shapes.AnnotatedMarker, {
            x: function(d, v) {
                if (v !== undefined) {
                    d.time = v;
                }
                return d.time;
            },
            color: function(d,v) {
                return markerColor(d);
            }
        });
        markerLayer.setBehavior(new wavesUI.behaviors.MarkerBehavior());
        track.add(markerLayer);

        // create cursorLayer
        cursorLayer = new wavesUI.helpers.CursorLayer({ height: layerHeight + timeAxisHeight, color: 'white' });
        timeline.addLayer(cursorLayer, 'main');

        cursorLayerMacro = new wavesUI.helpers.CursorLayer({ height: layerHeight, color: 'white' });
        timelineMacro.addLayer(cursorLayerMacro, 'macro');

        timeline.state = new wavesUI.states.SelectionState(timeline);
        timelineMacro.state = new wavesUI.states.SimpleEditionState(timelineMacro);
        segmentLayer.setContextEditable(false);

        finalDur = timeline.timeContext.visibleDuration;

        timeline.timeContext.zoom = finalDur / windowWidth;

        timeline.tracks.render();
        timeline.tracks.update();
        timelineMacro.tracks.render();
        timelineMacro.tracks.update();

        document.getElementById('loading').innerHTML = '';

        var uglyList = [1,2,3,42]; // placeholder thingy for pasting the giant document.
        // addMarkerList(uglyList);

        // updates the timeline every 20 ms when playing, every 200 ms when paused
        (function loop() {
            if (playSong) {
                var d = new Date();
                currentTime = (d.getTime() / 1000) - startTime;
                updatePlugin();
                setTimeout(requestAnimationFrame(loop), 20);
            } else {
                refreshClickQueue();
                updatePlugin();
                macroHighlight[0].x = - timeline.timeContext.offset;
                segmentLayerMacro.update();
                timeline.tracks.update();
                setTimeout(function() { requestAnimationFrame(loop); }, 50);
            }
        }());

        // WavesJS eventlistener for the lower timeline
        timeline.on('event', function(e) {
            var eventType = e.type;
            var segment = segmentLayer.getItemFromDOMElement(e.target);
            var onTimeAxis = $.inArray(timeAxis, timeline.getHitLayers(e));
            var onSegment = $.inArray(segmentLayer, timeline.getHitLayers(e));

            // highlight a segment when hovering above it
            if (segment !== null && (eventType == 'mouseover' || eventType == 'mouseout')) {
                var datum = segmentLayer.getDatumFromItem(segment);
                hoverSeg = eventType == 'mouseover' ? datum : null;
                segmentLayer.updateShapes();

            // when navigating the timeline
            } else if ((!onTimeAxis || onSegment) && eventType == 'mousemove') {
                mouseMoving = true;
                navigateTimeline(e, timeAxis);

            // when seeking or when done navigating the timeline
            } else if (!onTimeAxis && eventType == 'mouseup') {
                if (newMousePos == null) {
                    var newTime = timeline.timeToPixel.invert(e.x) - timeline.timeContext.offset;
                    player.seekTo(newTime);
                    seekTo(newTime);
                };
            }
        });

        // WavesJS eventlistener for the upper (macro) timeline
        timelineMacro.on('event', function(e) {
            var onTimeAxis = $.inArray(timeAxisMacro, timeline.getHitLayers);
            var eType = e.type;

            // when seeking, only updates viewing window
            if (onTimeAxis && eType == 'mousemove') {
                if (prevMousePos == null) {
                    prevMousePos = timeAxisMacro.timeToPixel.invert(e.x);
                } else {
                    mouseMoving = true;
                    timeline.timeContext.offset = -macroHighlight[0].x;
                    timeline.tracks.update();
                }

            // when done seeking
            } else if (onTimeAxis && eType == 'mouseup' && !mouseMoving) {
                var newTime = timeAxisMacro.timeToPixel.invert(e.x) - timelineMacro.timeContext.offset;
                player.seekTo(newTime);
                seekTo(newTime);
            } else if (eType == 'mouseup') {
                refreshWindowMacro();
                timeAxis.setTimeContext(timeline.timeContext);
                timeline.tracks.update();
            };
        });
    };

    // Renders all layers from the WavesJS plugin and plays a sound when
    // encountering a beat marker
    function updatePlugin() {
        // plays a clicksound when going past a beatmarker
        if(currentTime >= markerQueue[0]) {
            playClick(metronome);
            markerQueue.shift();
        }

        // updates cursor position
        if (!mouseMoving) {
            cursorLayer.currentPosition = currentTime;
            cursorLayer.update();
            cursorLayerMacro.currentPosition = currentTime;
            cursorLayerMacro.update();

        // updates the highlight on the upper timeline
        } else {
            macroHighlight[0].x = - timeline.timeContext.offset;
            segmentLayerMacro.update();
        }
        // updates lower timeline window position
        refreshWindow();

        if (currentTime >= finalDur) {
            player.pauseVideo();
            document.getElementById('playButton').innerHTML = '<i class="glyphicon glyphicon-pause"></i>'
        }
    }

    // moves the window of the lower timeline according to mouse movement
    function navigateTimeline(e, timeAxis) {
        if (prevMousePos == null) {
            prevMousePos = timeAxis.timeToPixel.invert(e.x);
            return;
        } else {
            newMousePos = timeAxis.timeToPixel.invert(e.x);
            var delta = newMousePos - prevMousePos;
            prevMousePos = newMousePos;
            timeline.timeContext.offset = timeline.timeContext.offset + delta;
            timeline.tracks.update();
        }
    }

    // called when seeking to a time
    function seekTo(newTime) {
        currentTime = newTime;
        var d = new Date();
        startTime = d.getTime()/1000 - currentTime;
        refreshClickQueue();
        audioplayer.currentTime = currentTime;
        updatePlugin();
    };

    // refreshes the viewing window from the lower timeline automatically
    function refreshWindow() {
        var offset = timeline.timeContext.offset;
        var padding = windowWidth/10;
        var cursorTooFar = currentTime+padding > (windowWidth - offset) || currentTime-padding < -offset;
        if (cursorTooFar && playSong) {
            if (padding + currentTime + windowWidth <= finalDur) {
                timeline.timeContext.offset = padding-currentTime;
                timeline.tracks.update();
            } else {
                timeline.timeContext.offset = windowWidth - finalDur;
                timeline.tracks.update();
            }
            macroHighlight[0].x = - timeline.timeContext.offset;
            segmentLayerMacro.update();
        }
    }

    // refreshes the viewing window manually
    function refreshWindowMacro() {
        var newWidth = macroHighlight[0].width;
        var windowXPos = macroHighlight[0].x;
        if (windowXPos < 0) {
            macroHighlight[0].x = 0;
        } else if ((windowXPos + newWidth) > finalDur) {
            newWidth = finalDur - windowXPos;
        }
        windowWidth = newWidth;
        timeline.timeContext.zoom = finalDur / windowWidth;
    }

    function timeSigChange() {
        var domSeg = segmentLayer.selectedItems[0];
        var segment = segmentLayer.getDatumFromItem(domSeg);
        segment.text = document.getElementById('timeSel').value;
        segmentLayer.update();
    };

    window.addEventListener("keydown", checkKeyPressed, false);

    // take action corresponding to the button press
    function checkKeyPressed(e) {

        // on 'spacebar' press
        if (e.keyCode == "32") {
            e.preventDefault();
            playOrPause();
            return false;

        // on 'b' press
        } else if (e.keyCode == "66") {
            playClick(true);
            addMarker(currentTime);

        // on 'delete' press
        } else if (e.keyCode == "46") {
            var domMarker = markerLayer.selectedItems[0];
            if (domMarker != undefined) {
                deleteMarker(markerLayer.getDatumFromItem(domMarker));
            } else {
                alert('Please select a beatmarker to delete');
            }
        }
    }

    // Pauses the YT video when it's playing and starts playback when it's paused.
    function playOrPause() {
        if (player.getPlayerState() == 1) {
            player.pauseVideo();
            document.getElementById('playButton').innerHTML = '<i class="glyphicon glyphicon-play"></i>'
        } else {
            refreshClickQueue();
            player.playVideo();
            document.getElementById('playButton').innerHTML = '<i class="glyphicon glyphicon-pause"></i>';
        }
    }

    window.addEventListener("mouseup", mouseUp, false);

    // when a mouseup is registered
    function mouseUp() {
        setTimeout(function(){
            // what to do with the time sig dropdown when a click is registered
            var domSeg = segmentLayer.selectedItems[0];
            if (domSeg != undefined) {
                document.getElementById("timeSigSelect").style.visibility = "visible";
                document.getElementById("timeSel").value = segmentLayer.getDatumFromItem(domSeg).text;
            } else {
                document.getElementById("timeSigSelect").style.visibility = "hidden";
            }

            newMousePos=null;
            mouseMoving = false;
            prevMousePos = null;

        },20)
    }

    // after confirm popup: goes back to song selection page
    function gotoSongSelection() {
        var confirm = window.confirm("Are you sure you want to start on a new song? Your progress on this song will not be saved.");
        if(!confirm) {
            return;
        }
        window.location = "index.html";
    }

    // creates a new beatmarker using the input time
    function addMarker(markerTime) {
        var newMarker = {
            time: markerTime,
            text: ' ',
        }
        beatMarkers.push(newMarker);
        markerLayer.render();
        markerLayer.update();
    }

    // deletes a specified marker
    function deleteMarker(marker) {
        var idx = beatMarkers.indexOf(marker);
        beatMarkers.splice(idx, 1);
        markerLayer.render();
        markerLayer.update();
    }

    // delete all the beatmarkers
    function clearMarkers() {
        var domSeg = segmentLayer.selectedItems[0];
        if (domSeg == undefined) {
            window.alert('Please select a segment to clear the markers from.');
            return;
        }

        var confirm = window.confirm("Are you sure you want to delete all beat markers in this segment?");
        if(!confirm) {
            return;
        }

        var segment = segmentLayer.getDatumFromItem(domSeg);
        var begin = segment.x;
        var end = begin+segment.width;
        deleteMarkersInRange(begin,end);

        markerLayer.render();
        markerLayer.update();
    }

    var currentClick = 1;
    var clickSound = new Audio('click.ogg');
    var clickSound2 = new Audio('click.ogg');

    // mute or unmute the click sound
    var metronome = true;
    function toggleClick() {
        if (metronome) {
            metronome = false;
            document.getElementById('clickToggle').innerHTML = '<span class="	glyphicon glyphicon-volume-off"></span>'
        } else {
            metronome = true;
            document.getElementById('clickToggle').innerHTML = '<span class="	glyphicon glyphicon-volume-up"></span>'
        }
    }

    // plays a clicksound, cycling between two audioplayers, to allow two
    // simultaneous audiostreams (for when 2 beats are very close to eachother)
    function playClick(shouldPlayClick) {
        if (currentClick == 1 && shouldPlayClick) {
            clickSound.play();
            currentClick = 2;
        } else if (currentClick == 2 && shouldPlayClick) {
            clickSound2.play();
            currentClick = 1;
        }
    }

    // refreshes the queue for when the clicksound should play
    function refreshClickQueue() {
        markerQueue = [];
        for (var i = 0; i < beatMarkers.length; i++) {
            if(beatMarkers[i].time > currentTime){
                markerQueue.push(beatMarkers[i].time);
            }
        }
        markerQueue.sort(function(a,b) {
            return a-b;
        });
    }

    // Creates a segment on selected marker and shortens the previous segment
    function splitSegOnBeat() {
        var domMarker = markerLayer.selectedItems[0];
        if (domMarker == undefined) {
            alert('Please select the beat to split a segment on');
            return;
        };

        var startTime = markerLayer.getDatumFromItem(domMarker).time;
        splitSegments(segments, startTime);
    }

    // Creates the new segment
    function splitSegments(segments, splitTime) {
        var newSegment = {
            x: splitTime,
            width: splitTime,
            height: layerHeight,
            top: timeAxisHeight,
            color: 'steelblue',
            opacity: 0,
            text: '4/4'
        };
        for (var i = 0; i < segments.length; i++) {
            var currentSeg = segments[i];
            if (currentSeg.x < splitTime && splitTime < (currentSeg.x + currentSeg.width)){
                oldWidth = currentSeg.width;
                currentSeg.width = splitTime - currentSeg.x;
                newSegment.width = oldWidth - currentSeg.width;
                segments.push(newSegment);
                break;
            }
        }
        segmentLayer.render();
        segmentLayer.update();
    }

    // merge 2 segments by removing selected segment and extending the previous
    function mergeSegments() {
        var domSeg = segmentLayer.selectedItems[0];
        if (domSeg == undefined) {
            alert('Please select a segment to merge');
            return;
        };

        var selectedSeg = segmentLayer.getDatumFromItem(domSeg);
        var mergeTime = selectedSeg.x;

        for (var i = 0; i < segments.length; i++) {
            var currentSeg = segments[i];
            if (mergeTime == (currentSeg.x + currentSeg.width)) {
                selectedSeg.x = currentSeg.x;
                selectedSeg.width = selectedSeg.width + currentSeg.width;
                segments.splice(i,1);
                break;
            }
        }
        segmentLayer.render();
        segmentLayer.update();
    }

    var hoverSeg = null;
    function segmentOpacity(seg) {
        var hovered = false;
        if (hoverSeg != null && hoverSeg == seg) {
            hovered = true;
        }
        var domSeg = segmentLayer.selectedItems[0];
        if (domSeg != undefined && segmentLayer.getDatumFromItem(domSeg) == seg) {
            return hovered ? 0.6 : 0.4;
        } else {
            return hovered ? 0.2 : 0;
        }
    }

    // change color of marker if it's the start of a segment or if it's selected
    function markerColor(marker) {
        var selected = false;
        var domMarker = markerLayer.selectedItems[0];
        if (domMarker != undefined && markerLayer.getDatumFromItem(domMarker) == marker) {
            selected = true;
        };

        for (var i = 0; i<segments.length; i++) {
            sameAsSegment = segments[i].x == marker.time;
            if (sameAsSegment) {
                return selected ? 'yellow' : '#cccc00';
            }
        }
        return selected ? '#ff0000' : '#bb0000';
    }

    // given a begin and end time, deletes all the markers between these times
    function deleteMarkersInRange(begin, end) {
        beatMarkers.sort(function(a,b){
            return a.time - b.time;
        });
        for(var i = 0; i < beatMarkers.length && beatMarkers[i].time < end; i++){
            if(beatMarkers[i].time > begin){
                beatMarkers.splice(i,1);
                i--;
            }
        }
    }

    // shows the registered beatmarkers on the page. No longer used
    function writeToPage() {
        document.getElementById('markerInfo').hidden = ""
        var objString = "[ ";
        for (i = 0; i < beatMarkers.length; i++) {
            var temp = beatMarkers[i];
            SingleObjString = "{ " + temp.time.toString() + ", " + temp.text.toString() + " },";
            objString = objString + SingleObjString;
        }
        objString = objString.replace(/,$/, "") + " ]";

        document.getElementById('markerInfo').value = objString;
    }

    // uploads the beatmarkers to the server
    function writeToFile() {
        var done = window.confirm("Are you sure you are done annotating? You cannot make any more changes after saving your annotations to the server.");
        if(!done) {
            return;
        }
        var toSend = [];
        for (i = 0; i < beatMarkers.length; i++) {
            toSend.push(beatMarkers[i].time);
        }
        var xhttp;
        var url = "writefile.php";
        var params = "beat="  + dataToString();
        // var params = "beat=" + toSend.toString();
        var ytID = "ytID=" + getYoutubeId();
        if (window.XMLHttpRequest) {
            // code for modern browsers
            xhttp = new XMLHttpRequest();
        } else {
            // code for IE6, IE5
            xhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        xhttp.open("POST", "writefile.php", true);
        //Send the proper header information along with the request
        xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        xhttp.onreadystatechange = function() {
            if (xhttp.readyState == 4 && xhttp.status == 200) {
                console.log(xhttp.responseText);
            }
        };
        xhttp.send(params + "&" + ytID);
        window.alert("Thank you! Your beat annotations are saved to the server.");
        window.location.assign('index.html');
    }

    // returns the data in the file format we want
    function dataToString() {
        var dataStr = '';
        segments.sort(function(a,b) {
            return a.x - b.x;
        });
        beatMarkers.sort(function(a,b) {
            return a.time - b.time;
        });
        var segTime;
        var segWidth;
        var j = 0;
        for (var i = 0; i<segments.length; i++) {
            segTime = segments[i].x;
            segWidth = segments[i].width;
            dataStr = dataStr + ';' + segments[i].text;

            while (j < beatMarkers.length && beatMarkers[j].time < (segTime + segWidth)) {
                dataStr = dataStr + ',' + beatMarkers[j].time.toString();
                j++;
            }
        }
        return dataStr;
    }

    // loops through a list with markers and adds them
    function addMarkerList(list) {
        for (var i = 0; i < list.length; i++) {
            addMarker(list[i]);
        }
    }

    // Use existing beats to estimate the rest
    function autocompletePHP() {
        {
        jQuery.ajax({
            type: "POST",
            url: 'autocomplete.php',
            data: {youtubeId: getYoutubeId()},
            success: function(data) {
            }
        });
        }
        $.get("./onsets/"+ getYoutubeId() + "_vamp_qm-vamp-plugins_qm-onsetdetector_onsets.csv", function(data, status){
            var onsetData = data.split("\n");
            for (var i = 0; i < onsetData.length; i++) {
                onsetData[i] = parseFloat(onsetData[i]);
            }

            // get the current segment begin and end time + all markers in that segment
            begin = 0;
            end = 0;
            var domSeg = segmentLayer.selectedItems[0];
            if (domSeg == undefined) {
                alert('Please select a segment to auto-complete');
                return;
            }
            begin = segmentLayer.getDatumFromItem(domSeg).x;
            end = segmentLayer.getDatumFromItem(domSeg).width + segmentLayer.getDatumFromItem(domSeg).x;

            var markerTimes = [];
            for (i = 0; i < beatMarkers.length; i++) {
                if(begin < beatMarkers[i].time && beatMarkers[i].time < end) {
                    markerTimes.push(beatMarkers[i].time);
                }
            }
            markerTimes.sort(function(a,b) {
                return a-b;
            });
            var beatsToAdd = autocompleteAlgorithm(markerTimes, onsetData, begin, end);
            if (!beatsToAdd) {
                return;
            }
            addMarkerList(beatsToAdd);
        });
    }

    // The algorithm used to auto-complete segments
    function autocompleteAlgorithm(userbeats, onsetbeats, begin, end) {
        truebeats = [];
        for(var i = 0; i < userbeats.length; i++) {
            if (userbeats[i] <= end && userbeats[i] >= begin) {
                truebeats.push(userbeats[i]);
            }
        }
        if (truebeats.length < 6) {
            alert("You need to annotate some more beats yourself, before it can be completed.");
            return false;
        }

        interval = getInterval(truebeats);

        addedbeats = [];
        // looks for gaps to add beats
        for (var i = 0; i < truebeats.length-1; i++) {
            // if two beats are too far apart, we fill in the gap
            prevbeat = truebeats[i];
            while (truebeats[i+1] - prevbeat > interval * 1.5) { // 1.5 can be balanced
                roughtime = prevbeat+interval;
                var best = [roughtime, 0.01]; // 0.02 can be balanced
                for (var j = 0; j < onsetbeats.length; j++) {  //TODO: Dit kan veel, veel sneller met een beetje een intelligent zoekalgoritme. Maar is niet heel eenvoudig....
                    if (Math.abs(onsetbeats[j] - roughtime) < best[1]) {
                        best = [onsetbeats[j], Math.abs(onsetbeats[j] - roughtime)];
                    }
                }
                prevbeat = best[0];
                addedbeats.push(best[0]);
            }
        }

        // last beat needs to be compared to the end, as it cannot be compared to the next beat. I'm just making a seperate code-block for that and copypasting most of it from above.
        prevbeat = truebeats[truebeats.length-1];
        while (end - prevbeat > interval * 1.5) { // 1.5 can be balanced
            roughtime = prevbeat+interval;
            var best = [roughtime, 0.01]; // 0.02 can be balanced
            for (var j = 0; j < onsetbeats.length; j++) {  //TODO: Dit kan veel, veel sneller met een beetje een intelligent zoekalgoritme. Maar is niet heel eenvoudig....
                if (Math.abs(onsetbeats[j] - roughtime) < best[1]) {
                    best = [onsetbeats[j], Math.abs(onsetbeats[j] - roughtime)];
                }
            }
            prevbeat = best[0];
            addedbeats.push(best[0]);
        }
        return addedbeats;
    }

    // returns average interval between the input timings
    function getInterval(times) {
        intervals = [];
        for(var i = 0; i < times.length-1; i++) {
            intervals[i] = times[i+1] - times[i];
        }
        intervals.sort(function(a,b) {
            return a-b;
        });
        middlepart = [];
        for(var i = Math.floor(intervals.length/4); i < Math.floor(intervals.length/4)*3; i++) {
            middlepart.push(intervals[i]);
        }
        var sum = 0;
        for( var i = 0; i < middlepart.length; i++ ){
            sum += middlepart[i];
        }

        var pseudoAvg = sum/middlepart.length;
        return pseudoAvg;
    }

    </script>
</body>

</html>
